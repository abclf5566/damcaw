<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8">
    <!-- å‘Šè¨´ç€è¦½å™¨æ”¯æ´é›™ä¸»é¡Œ -->
    <meta name="color-scheme" content="light dark">
    <!-- å…ˆæº–å‚™æ·±è‰²èƒŒæ™¯ï¼Œé¿å…ç™½å± -->
    <style>html[data-theme="dark"]{background:#121212;}</style>
  
    <script>
      // è®€ localStorageï¼ˆ'true' / 'false' / nullï¼‰
      const saved = localStorage.getItem('prefersDark');
      let useDark;
      if (saved === 'true')      useDark = true;
      else if (saved === 'false') useDark = false;
      else                        useDark = matchMedia('(prefers-color-scheme: dark)').matches;

      // æŠŠçµæœå¯«é€² <html>
      if (useDark) {
        document.documentElement.dataset.theme = 'dark';
        document.documentElement.style.background = '#121212'; // é é˜²ç™½é–ƒ
      } else {
        document.documentElement.dataset.theme = 'light';
      }
    </script>
  
    <title>æ·±åº¦è²·è³£è¨ˆç®—å™¨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="style.css?v=20250426">
  </head>
  
<body>
  <div class="calculator" style="max-width: 720px; margin: 0.7em auto; padding: 0.4em 0.6em; background: var(--card-bg); border-radius: 8px; box-shadow: 0 0 6px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 0.4em;">
  <h2 style="font-size: 1.4em; margin: 0 0 0.15em 0;">ğŸ“Š æ·±åº¦è²·è³£è¨ˆç®—å™¨ï¼ˆCoinEx & Pionexï¼‰</h2>
  <label ><input type="checkbox" id="darkToggle"> ğŸŒ™ æ·±è‰²æ¨¡å¼</label>
  <div class="row-flex form-row">
  <div style="display: flex; flex-direction: column; gap: 0.25em;">
    <label>äº¤æ˜“æ‰€:<select id="exchange" onchange="updateTokenOptions()">
      <option value="coinex">CoinEx</option>
      <option value="pionex">Pionex</option>
    </select></label>
  </div>
  <div style="display: flex; flex-direction: column; gap: 0.25em;">
    <label>ä»£å¹£:<input id="symbol" list="symbolList" autocomplete="on"></label>
    <datalist id="symbolList"></datalist>
  </div>
  <div style="display: flex; flex-direction: column; gap: 0.25em;">
    <label>é‡‘é¡/æ•¸é‡:<input id="amount" type="number" value="1000"></label>
  </div>
  <div style="display: flex; flex-direction: column; gap: 0.25em;">
    <label>æ“ä½œ:<select id="action">
      <option value="buy">è²·å…¥</option>
      <option value="sell">è³£å‡º</option>
    </select></label>
  </div>
  <div style="display: flex; flex-direction: column; gap: 0.25em;">
    <label>æ‰‹çºŒè²»(%):<input id="fee" type="number" value="0.1"></label>
  </div>
  <div style="display: flex; flex-direction: column; gap: 0.25em;">
    <label><input type="checkbox" id="cet"> CET æŠ˜æ‰£</label>
  </div>
</div>

  <div style="padding:0.4em 0.6em; font-size:0.95em;">
    <div id="result" style="white-space: pre-wrap;"></div>
    <div id="error" style="color: #f87171; font-weight: bold; margin-top: 0.5em; min-height: 1.5em;"></div>
  </div>

  <!-- <script>
    const tokenList = {
      coinex: ['KASPER', 'KASPY', 'KDAO', 'GHOAD', 'BURT', 'KEIRO', 'KANGO', 'NACHO', 'KREX', 'KEKE', 'BTC', 'ETH', 'SOL', 'KAS'],
      pionex: ['GHOAD', 'KANGO', 'NACHO', 'KAS', 'BTC', 'ETH', 'SOL']
    };
    

    let loopId = null;

    function updateTokenOptions() {
      const exchange = document.getElementById('exchange').value;
      const symbolList = document.getElementById('symbolList');
      const feeInput = document.getElementById('fee');

      // æ ¹æ“šé¸æ“‡çš„äº¤æ˜“æ‰€è¨­å®šé è¨­æ‰‹çºŒè²»
      if (exchange === 'coinex') {
        feeInput.value = '0.3';
      } else if (exchange === 'pionex') {
        feeInput.value = '0.1';
      }

      symbolList.innerHTML = '';
      const uniqueTokens = [...new Set(tokenList[exchange])];
      uniqueTokens.forEach(token => {
        const option = document.createElement('option');
        option.value = token;
        symbolList.appendChild(option);
      });
    }

    async function fetchDepth(exchange, symbol) {
      const proxy = 'https://cors.neon-game.com/';;;
      try {
        if (exchange === 'coinex') {
          const url = `${proxy}https://api.coinex.com/v2/spot/depth?market=${symbol.toUpperCase()}USDT&limit=50&interval=0`;
          const res = await fetch(url);
          const json = await res.json();
    console.log("[DEBUG] CoinEx Response:", json);
console.log("[DEBUG] CoinEx URL:", url);
          const depth = json?.data?.depth ?? {};
          if (!depth.asks || !depth.bids || !Array.isArray(depth.asks) || !Array.isArray(depth.bids)) {
            throw new Error("CoinEx å›å‚³è³‡æ–™æ ¼å¼éŒ¯èª¤");
          }
          return depth;
        } else {
          const url = `${proxy}https://api.pionex.com/api/v1/market/depth?symbol=${symbol.toUpperCase()}_USDT&limit=500`;
          const res = await fetch(url);
          const json = await res.json();
    console.log("[DEBUG] Pionex Response:", json);
          if (!json?.result || !json?.data || !Array.isArray(json.data.asks) || !Array.isArray(json.data.bids) || json.data.asks.length === 0 || json.data.bids.length === 0) {
            throw new Error("Pionex API å›å‚³ç©ºæˆ–ç„¡æ•ˆæ·±åº¦è³‡æ–™ï¼ˆå¯èƒ½ç‚ºç„¡æ•ˆå¸‚å ´ï¼‰");
          }
          return json.data;
        }
      } catch (err) {
        throw new Error("å–å¾—æ·±åº¦è³‡æ–™å¤±æ•—ï¼š" + err.message);
      }
        }


    function calculateCoinex(depth, action, amount, feeRate, cetDiscount) {
      const asks = depth.asks;
      const bids = depth.bids;
      if (!asks || !bids) return [0, 0, 0];
      const book = action === 'buy' ? asks : bids;

      let remaining = amount;
      let total = 0, weightedSum = 0, totalVol = 0;
      for (const [priceStr, volStr] of book) {
        const price = parseFloat(priceStr), volume = parseFloat(volStr);
        const cost = action === 'buy' ? price * volume : volume;
        if (remaining >= cost) {
          total += action === 'buy' ? volume : price * volume;
          remaining -= cost;
          weightedSum += price * volume;
          totalVol += volume;
        } else {
          const partial = action === 'buy' ? remaining / price : remaining;
          total += action === 'buy' ? partial : price * partial;
          weightedSum += price * partial;
          totalVol += partial;
          break;
        }
      }
      if (totalVol === 0) return [0, 0, 0];
      const avgPrice = weightedSum / totalVol, bestPrice = parseFloat(book[0][0]);
      const slippage = action === 'buy' ? ((avgPrice - bestPrice) / bestPrice) * 100 : ((bestPrice - avgPrice) / bestPrice) * 100;
      const fee = total * (cetDiscount ? feeRate * 0.8 : feeRate);
      return [total - fee, slippage, fee];
    }

    function calculatePionex(depth, action, amount, feeRate, cetDiscount) {
      const asks = depth.asks;
      const bids = depth.bids;
      if (!asks || !bids) return [0, 0, 0];
      const book = action === 'buy' ? asks : bids;

      let remaining = amount;
      let total = 0, weightedSum = 0, totalVol = 0;
      for (const [priceStr, volStr] of book) {
        const price = parseFloat(priceStr), volume = parseFloat(volStr);
        const cost = price * volume;
        if (action === 'buy') {
          if (remaining >= cost) {
            total += volume;
            remaining -= cost;
            weightedSum += price * volume;
            totalVol += volume;
          } else {
            const partial = remaining / price;
            total += partial;
            weightedSum += price * partial;
            totalVol += partial;
            break;
          }
        } else {
          if (remaining >= volume) {
            total += price * volume;
            remaining -= volume;
            weightedSum += price * volume;
            totalVol += volume;
          } else {
            total += price * remaining;
            weightedSum += price * remaining;
            totalVol += remaining;
            break;
          }
        }
      }
      if (totalVol === 0) return [0, 0, 0];
      const avgPrice = weightedSum / totalVol, bestPrice = parseFloat(book[0][0]);
      const slippage = action === 'buy' ? ((avgPrice - bestPrice) / bestPrice) * 100 : ((bestPrice - avgPrice) / bestPrice) * 100;
      const fee = total * (cetDiscount ? feeRate * 0.8 : feeRate);
      return [total - fee, slippage, fee];
    }

    async function run() {
      const exchange = document.getElementById('exchange').value;
      const symbol = document.getElementById('symbol').value.trim();
      const resultDiv = document.getElementById('result');
      const errorDiv = document.getElementById('error');

      // è‹¥ä»£å¹£ç‚ºç©ºï¼Œåœæ­¢æ›´æ–°ä¸¦æ¸…ç©ºçµæœ
      if (!symbol) {
        if (loopId) clearInterval(loopId);
        errorDiv.textContent = '';
        resultDiv.innerHTML = '';
        return;
      }

      const amount = parseFloat(document.getElementById('amount').value);
      const action = document.getElementById('action').value;
      const feeRate = parseFloat(document.getElementById('fee').value) / 100;
      const cet = document.getElementById('cet').checked;

      try {
        const depth = await fetchDepth(exchange, symbol);
        const [net, slip, fee] = exchange === 'coinex'
          ? calculateCoinex(depth, action, amount, feeRate, cet)
          : calculatePionex(depth, action, amount, feeRate, cet);

        const slipColor = slip > 10 ? 'red' : slip > 5 ? 'orange' : 'inherit';
        const display = `ğŸ’° æ·¨ç²å¾—æ•¸é‡ï¼š${net.toFixed(4)} ${action === 'buy' ? symbol.toUpperCase() : 'USDT'}
ğŸ’¸ æ‰‹çºŒè²»ï¼š${fee.toFixed(4)} ${action === 'buy' ? symbol.toUpperCase() : 'USDT'}
ğŸ“‰ æ»‘é»ï¼š<span style="color: ${slipColor}; font-weight: bold">${slip.toFixed(2)}%</span>`;
        resultDiv.innerHTML = display;
        errorDiv.textContent = '';
      } catch (err) {
        errorDiv.textContent = "âŒ éŒ¯èª¤ï¼šã€Œ" + err.message + "ã€";
      }
    }

    updateTokenOptions();

    // æ·±è‰²æ¨¡å¼åˆå§‹åŒ– + åˆ‡æ›åŠŸèƒ½
    const darkToggle = document.getElementById('darkToggle');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (prefersDark) {
      document.documentElement.setAttribute('data-theme', 'dark');
      darkToggle.checked = true;
    }
    darkToggle.addEventListener('change', () => {
      document.documentElement.setAttribute('data-theme', darkToggle.checked ? 'dark' : 'light');
    });

    // ç•¶ symbol æœ‰è®ŠåŒ–æ™‚è‡ªå‹•åŸ·è¡Œè¨ˆç®—
    document.getElementById('symbol').addEventListener('input', () => {
      const symbol = document.getElementById('symbol').value.trim();
      if (symbol !== '') {
        if (loopId) clearInterval(loopId);
        run();
        loopId = setInterval(run, 1000);
      }
    });
  </script> -->
  <!-- <script type="module" src="function.js?v=20250526"></script> -->
</div>
<button id="addCalculator" style="margin: 2em auto 0; display: block; padding: 0.5em 1em; font-size: 1em; background: var(--primary, #3b82f6); color: white; border: none; border-radius: 6px; cursor: pointer;">â• æ–°å¢è¨ˆç®—å™¨</button>

<!-- <script>
let calculatorCount = 1;
const MAX_CALCULATORS = 10;

const baseCalculator = document.querySelector('div[style*="max-width: 720px"]');
const addBtn = document.getElementById('addCalculator');

addBtn.addEventListener('click', () => {
  if (calculatorCount >= MAX_CALCULATORS) return alert("æœ€å¤šåªèƒ½æ–°å¢ 10 å€‹è¨ˆç®—å™¨");

  const clone = baseCalculator.cloneNode(true);
  calculatorCount++;

  // ç§»é™¤æ¨™é¡Œå’Œæ·±è‰²åˆ‡æ›
  const title = clone.querySelector('h2');
  if (title) title.remove();
  const darkToggle = clone.querySelector('#darkToggle')?.parentElement;
  if (darkToggle) darkToggle.remove();

  // æ¸…ç©ºè¼¸å…¥èˆ‡çµæœ
  clone.querySelectorAll('input').forEach(input => {
    if (input.type === 'number') input.value = '1000';
    if (input.type === 'checkbox') input.checked = false;
    if (input.id.startsWith('symbol')) input.value = '';
  });
  clone.querySelector('#result').textContent = '';
  clone.querySelector('#error').textContent = '';

  // æ›´æ–° clone ä¸­æ‰€æœ‰ id ç‚ºå”¯ä¸€å€¼ï¼Œé¿å…è¡çª
  const newIdSuffix = `_${calculatorCount}`;
  const symbolInput = clone.querySelector('[id^="symbol"]');
  clone.querySelectorAll('[id]').forEach(el => {
    const oldId = el.id;
    // é‡æ–°å‘½åæ‰€æœ‰ idï¼ˆåŒ…å« datalistï¼‰ä»¥é¿å…è¡çª
    const newId = oldId + newIdSuffix;
    el.id = newId;
    if (el.tagName === 'LABEL') el.setAttribute('for', newId);
  });
  // è®“ symbol input æŒ‡å‘å°æ‡‰ datalist
  const dl = clone.querySelector('datalist');
  if (dl && symbolInput) symbolInput.setAttribute('list', dl.id);

    // ç¶å®šè‡ªå‹•æ›´æ–°è¨ˆç®—åŠŸèƒ½
  // symbolInput å·²åœ¨å‰é¢å®£å‘Š
  const exchangeSelect = clone.querySelector(`[id^="exchange"]`);
  const feeInput = clone.querySelector(`[id^="fee"]`);
  const resultDiv = clone.querySelector(`[id^="result"]`);
  const errorDiv = clone.querySelector(`[id^="error"]`);

  function updateCloneTokens() {
    const selEx = exchangeSelect.value.toLowerCase();
    feeInput.value = selEx === 'coinex' ? '0.3' : '0.1';
    const dl = clone.querySelector('datalist');
    dl.innerHTML = '';
    (tokenList[selEx] || []).forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      dl.appendChild(opt);
    });
  }
  updateCloneTokens();
  exchangeSelect.addEventListener('change', () => {
  updateCloneTokens();            // åŸæœ¬å°±æœ‰çš„
  if (symbolInput.value.trim()) { // ä»£å¹£ä¸ç‚ºç©ºæ‰é‡ç®—
    if (loop) clearInterval(loop);
    runScoped();
    loop = setInterval(runScoped, 1000);
  }
});


  let loop = null;
  symbolInput.addEventListener('input', async () => {
    const symbol = symbolInput.value.trim();
    if (symbol !== '') {
      if (loop) clearInterval(loop);
      const runScoped = async () => {
        try {
          const exchange = exchangeSelect.value;
          const amount = parseFloat(clone.querySelector(`[id^="amount"]`).value);
          const action = clone.querySelector(`[id^="action"]`).value;
          const feeRate = parseFloat(clone.querySelector(`[id^="fee"]`).value) / 100;
          const cet = clone.querySelector(`[id^="cet"]`).checked;

          const depth = await fetchDepth(exchange, symbol);
          const [net, slip, fee] = exchange === 'coinex'
            ? calculateCoinex(depth, action, amount, feeRate, cet)
            : calculatePionex(depth, action, amount, feeRate, cet);

          const slipColor = slip > 10 ? 'red' : slip > 5 ? 'orange' : 'inherit';
          const display = `ğŸ’° æ·¨ç²å¾—æ•¸é‡ï¼š${net.toFixed(4)} ${action === 'buy' ? symbol.toUpperCase() : 'USDT'}
ğŸ’¸ æ‰‹çºŒè²»ï¼š${fee.toFixed(4)} ${action === 'buy' ? symbol.toUpperCase() : 'USDT'}
ğŸ“‰ æ»‘é»ï¼š<span style='color: ${slipColor}; font-weight: bold'>${slip.toFixed(2)}%</span>`;
          resultDiv.innerHTML = display;
          errorDiv.textContent = '';
        } catch (err) {
          errorDiv.textContent = 'âŒ éŒ¯èª¤ï¼šã€Œ' + err.message + 'ã€';
        }
      };
      await runScoped();
      loop = setInterval(runScoped, 1000);
    }
  });

  // åŠ å…¥åˆªé™¤æŒ‰éˆ•
  const delBtn = document.createElement('button');
  delBtn.textContent = 'ğŸ—‘ï¸ åˆªé™¤';
  delBtn.className = 'delete-btn';
  delBtn.onclick = () => {
    if (loop) clearInterval(loop);
    clone.remove();
    calculatorCount--;
  };
  clone.appendChild(delBtn);

  document.body.insertBefore(clone, addBtn);
});
</script> -->

<!-- <script>
  // ========= æœ¬æ®µç‚ºç‹€æ…‹æŒä¹…åŒ– =========
  const STORAGE_KEY = 'calc_state_v1';
  /* ---- 0. è¼•é‡å„²å­˜å°è£ ---- */
  const StorageSafe = (() => {
    let inMemory = null;                 // å¾Œå‚™è¨˜æ†¶é«”
    const key = 'calc_state_v1';

    function get(){
      try{
        return localStorage.getItem(key);
      }catch(e){
        return inMemory;
      }
    }
    function set(val){
      try{
        localStorage.setItem(key, val);
      }catch(e){
        inMemory = val;                  // fallback
      }
    }
    function remove(){
      try{ localStorage.removeItem(key);} catch(e){ inMemory = null; }
    }
    return {get,set,remove};
  })();  

  // æ”¶é›†ç›®å‰æ‰€æœ‰è¨ˆç®—å™¨ç‹€æ…‹ä¸¦å­˜å…¥ localStorage
  function saveState(){
    const cards = document.querySelectorAll('.calculator');
    const list = [];
    cards.forEach(card=>{
       const get = sel=>card.querySelector(sel);
       list.push({
          exchange: get('[id^="exchange"]').value,
          symbol:   get('[id^="symbol"]').value,
          amount:   get('[id^="amount"]').value,
          action:   get('[id^="action"]').value,
          fee:      get('[id^="fee"]').value,
          cet:      get('[id^="cet"]').checked
       });
    });
    const dark = document.documentElement.getAttribute('data-theme')==='dark';
    localStorage.setItem(STORAGE_KEY, JSON.stringify({cards:list,dark}));
    StorageSafe.set(JSON.stringify({cards:list,dark}));
  }
  
  // è®€å– localStorage æ¢å¾© UI
  function restoreState(){
    const raw = StorageSafe.get();
  if(!raw) return;
    try{
       const {cards,dark}=JSON.parse(raw);
       if(dark){document.documentElement.setAttribute('data-theme','dark');document.getElementById('darkToggle').checked=true;}
       if(Array.isArray(cards)&&cards.length){
          // ç¬¬ä¸€å¼µè¦†å¯«ä¸»å¡
          fillCard(document.querySelector('.calculator'), cards[0]);
          // å…¶é¤˜ç”¨ add æŒ‰éˆ•ç”¢ç”Ÿ
          for(let i=1;i<cards.length;i++){
             const card = addCalculatorProgrammatically();
             fillCard(card, cards[i]);
          }
       }
    }catch(e){console.warn('restore fail',e);}
  }
  
  // æŠŠè³‡æ–™å¯«å›å¡ç‰‡
  function fillCard(card, data) {
  const set = (sel, v) => {
    const el = card.querySelector(sel);
    if (el) el.value = v;
  };

  // ===== 1. å¯«å…¥æ‰€æœ‰æ¬„ä½ =====
  set('[id^="exchange"]', data.exchange);

  // ä¸»å¡ç”¨å…¨åŸŸ updateTokenOptions()ï¼Œclone å¦å¤–æœ‰ updateCloneTokens()
  if (card === document.querySelector('.calculator')) {
    updateTokenOptions();
  } else {
    // é€™è£¡çš„ updateCloneTokens å·²åœ¨ addCalculator å…§å®£å‘Š
    card.updateCloneTokens && card.updateCloneTokens();
  }

  set('[id^="symbol"]',  data.symbol);
  set('[id^="amount"]',  data.amount);
  set('[id^="action"]',  data.action);
  set('[id^="fee"]',     data.fee);
  const cet = card.querySelector('[id^="cet"]');
  if (cet) cet.checked = data.cet;

  // ===== 2. å…¨éƒ¨å¯«å®Œå†è§¸ç™¼ä¸€æ¬¡è¨ˆç®— =====
  if (data.symbol) {
    if (card === document.querySelector('.calculator')) {
      // ä¸»å¡ï¼šrun() + loopId
      run();
      if (loopId) clearInterval(loopId);
      loopId = setInterval(run, 1000);
    } else {
      // clone å¡ï¼šç”¨ dispatch è§¸ç™¼å®ƒåŸæœ¬çš„ listener â†’ runScoped()
      const evt = new Event('input', { bubbles: true });
      card.querySelector('[id^="symbol"]').dispatchEvent(evt);
    }
  }
}

  
  // åŒ…è£åŸæœ¬ add æŒ‰éˆ•è¡Œç‚ºï¼Œä½¿ç¨‹å¼åŒ–å‘¼å«ä¹Ÿèƒ½ç”¨
  function addCalculatorProgrammatically(){
     addBtn.click();
     return document.body.querySelectorAll('.calculator')[document.body.querySelectorAll('.calculator').length-1];
  }
  
  // åœ¨æ‰€æœ‰è¼¸å…¥è®Šå‹•ã€åˆªé™¤ã€æ–°å¢å¾Œå‘¼å« saveState
  const observeChange = new MutationObserver(saveState);
  observeChange.observe(document.body,{subtree:true,childList:true});
  
  document.body.addEventListener('input', e=>{ if(e.target.matches('input,select')) saveState(); });
  document.body.addEventListener('change', e=>{ if(e.target.matches('input,select')) saveState(); });
  
  window.addEventListener('DOMContentLoaded', restoreState);
  // ========= æŒä¹…åŒ–çµæŸ =========
  </script> -->
<script type="module" src="app.js?v=20250526"></script>
</body>
</html>
